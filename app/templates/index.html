<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>NCPyVisual</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css">
  <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>
  <style>
    html, body { height:100%; margin:0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background:#f0f2f5; overflow:hidden; }

    .app {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .app__header {
      height: 56px;
      background: #fff;
      border-bottom: 1px solid #d9d9d9;
      display: flex;
      align-items: center;
      padding: 0 16px;
      flex-shrink: 0;
    }

    .app__header h1 {
      font-size: 1.25rem;
      margin: 0;
    }

    .app__main {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    .app__results {
      height: 350px;
      background: #fff;
      border-top: 2px solid #2196f3;
      overflow: hidden;
      flex-shrink: 0;
    }

    .side {
      width: 340px;
      background: #fafafa;
      border-right: 1px solid #d9d9d9;
      padding: 16px;
      overflow: auto;
      flex-shrink: 0;
    }

    .side h3 {
      margin: 16px 0 8px;
    }

    .block {
      background: #fff;
      border: 1px solid #e3e3e3;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .form-row {
      margin-bottom: 10px;
    }

    .form-row label {
      display: block;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .form-row input[type="text"], .form-row input[type="password"], .form-row input[type="number"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
    }

    .btn {
      width: 100%;
      padding: 10px;
      border: 0;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 6px;
      font-size: 0.95rem;
    }

    .btn--primary { background: #007bff; color: #fff; }
    .btn--success { background: #28a745; color: #fff; }
    .btn--warn { background: #ffc107; color: #000; }
    .btn--danger { background: #dc3545; color: #fff; }
    .btn--muted { background: #6c757d; color: #fff; }
    .btn--debug { background: #17a2b8; color: #fff; }
    .btn--small { padding: 4px 8px; font-size: 0.8rem; margin: 2px; width: auto; }

    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 16px;
      overflow: hidden;
      background: #e9e9e9;
      position: relative;
    }

    .image-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
      background: rgba(255,255,255,0.9);
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .image-controls button {
      padding: 6px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
      font-size: 12px;
    }

    .image-controls button:hover {
      background: #f0f0f0;
    }

    .image-controls .zoom-info {
      margin-left: auto;
      font-size: 12px;
      color: #666;
      background: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    #image-canvas {
      background: #fff;
      box-shadow: 0 4px 8px rgba(0,0,0,.08);
      border-radius: 4px;
      cursor: grab;
    }

    #image-canvas.panning {
      cursor: grabbing;
    }

    #loader {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,.7);
      z-index: 999;
    }

    .spinner {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 8px solid #eee;
      border-top-color: #3498db;
      animation: spin 1s linear infinite;
    }

    @keyframes spin{to{transform:rotate(360deg)}}

    .results-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: #fff;
    }

    .results-header {
      background: #2196f3;
      color: white;
      padding: 12px 16px;
      font-weight: bold;
      font-size: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .results-toggle {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .results-toggle:hover {
      background: rgba(255,255,255,0.3);
    }

    .results-stats {
      background: #e3f2fd;
      padding: 8px 16px;
      border-bottom: 1px solid #ddd;
      font-size: 14px;
      flex-shrink: 0;
    }

    .results-content {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .results-table-container {
      flex: 1;
      overflow: auto;
      border: 1px solid #ddd;
    }

    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      min-width: 1200px;
    }

    .results-table th {
      background: #f5f5f5;
      border: 1px solid #ddd;
      padding: 10px 6px;
      text-align: left;
      font-weight: bold;
      position: sticky;
      top: 0;
      z-index: 10;
      white-space: nowrap;
    }

    .results-table td {
      border: 1px solid #ddd;
      padding: 8px 6px;
      max-width: 150px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .results-table tr:nth-child(even) {
      background: #f9f9f9;
    }

    .results-table tr:hover {
      background: #e3f2fd;
    }

    .confidence-excellent { background-color: #c8e6c9 !important; }
    .confidence-good { background-color: #fff3c4 !important; }
    .confidence-poor { background-color: #ffcdd2 !important; }

    .plate-thumb {
      width: 80px;
      height: 25px;
      object-fit: contain;
      border: 1px solid #ddd;
      border-radius: 2px;
      cursor: pointer;
    }

    .plate-thumb:hover {
      border-color: #2196f3;
      box-shadow: 0 2px 4px rgba(33,150,243,0.3);
    }

    .no-plate-info {
      color: #666;
      font-style: italic;
      font-size: 11px;
    }

    .plate-status-missing {
      background-color: #ffeb3b !important;
      color: #f57c00;
      font-weight: bold;
    }

    .plate-status-error {
      background-color: #ffcdd2 !important;
      color: #c62828;
      font-weight: bold;
    }

    .plate-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      cursor: pointer;
    }

    .plate-modal-content {
      max-width: 90%;
      max-height: 90%;
      background: white;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }

    .plate-modal img {
      max-width: 100%;
      max-height: 70vh;
      object-fit: contain;
      border: 3px solid #2196f3;
      border-radius: 4px;
    }

    .gallery-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .gallery-stats {
      font-size: 12px;
      color: #666;
    }

    .gallery {
      max-height: 300px;
      overflow-y: auto;
      border: 2px dashed #ddd;
      background: #fff;
      border-radius: 6px;
      padding: 8px;
      transition: border-color 0.3s;
    }

    .gallery.drag-over {
      border-color: #2196f3;
      background-color: #e3f2fd;
    }

    .gallery-empty {
      text-align: center;
      color: #999;
      font-style: italic;
      padding: 20px;
    }

    .gallery-item {
          display: flex;
          align-items: center;
          background: #f9f9f9;
          border: 1px solid #ddd;
          border-radius: 4px;
          margin-bottom: 4px;
          padding: 8px;
          position: relative;
        }

        .gallery-item:hover {
          background: #e3f2fd;
          border-color: #2196f3;
        }

        .gallery-item.active {
          background: #e8f5e8;
          border-color: #4caf50;
          box-shadow: 0 2px 4px rgba(76,175,80,0.3);
        }

        .gallery-thumb {
          width: 80px;
          height: 60px;
          object-fit: cover;
          border-radius: 3px;
          border: 1px solid #ccc;
          cursor: pointer;
          margin-right: 10px;
        }

        .gallery-info {
          flex: 1;
          display: flex;
          flex-direction: column;
          min-width: 0;
        }

        .gallery-filename {
          font-weight: bold;
          font-size: 12px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }

        .gallery-details {
          font-size: 11px;
          color: #666;
          margin-top: 2px;
        }

        .gallery-actions {
          display: flex;
          flex-direction: column;
          gap: 2px;
        }

        .gallery-item .btn--small {
          min-width: 60px;
        }

        .status-badge {
          padding: 2px 6px;
          border-radius: 12px;
          font-size: 10px;
          font-weight: bold;
          text-transform: uppercase;
        }

        .status-success { background: #c8e6c9; color: #2e7d32; }
        .status-warning { background: #fff3c4; color: #f57c00; }
        .status-error { background: #ffcdd2; color: #c62828; }

        input[type="file"]{ display:none; }
        .filelike { display:inline-block; width:100%; text-align:center; padding:10px; border:1px solid #ccc; border-radius:8px; cursor:pointer; background:#f9f9f9; box-sizing: border-box; transition: background 0.3s; }
        .filelike:hover { background: #e3f2fd; border-color: #2196f3; }
        .panel-title { margin-top:14px; border-top:2px solid #ddd; padding-top:10px; font-size:1.05rem; }
        pre { white-space:pre-wrap; word-wrap:break-word; background:#fff; border:1px solid #eee; border-radius:8px; padding:10px; max-height: 200px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 11px; }
        .result-summary { background:#e8f5e8; border:1px solid #4caf50; border-radius:6px; padding:12px; margin:8px 0; }
        .result-error { background:#ffe8e8; border:1px solid #f44336; border-radius:6px; padding:12px; margin:8px 0; }
        .result-info { background:#e3f2fd; border:1px solid #2196f3; border-radius:6px; padding:12px; margin:8px 0; }

        .debug-info {
          background: #fff3e0;
          border: 1px solid #ff9800;
          border-radius: 6px;
          padding: 8px;
          margin: 4px 0;
          font-size: 11px;
          color: #e65100;
        }

        .debug-info strong {
          color: #bf360c;
        }

        .drop-zone {
          border: 2px dashed #ccc;
          border-radius: 8px;
          padding: 20px;
          text-align: center;
          background: #f9f9f9;
          transition: all 0.3s;
          cursor: pointer;
        }

        .drop-zone:hover, .drop-zone.drag-over {
          border-color: #2196f3;
          background: #e3f2fd;
        }

        .drop-zone-text {
          color: #666;
          font-size: 14px;
        }

        .canvas-wrapper {
          flex: 1;
          display: flex;
          align-items: center;
          justify-content: center;
          overflow: hidden;
          position: relative;
          background: #f0f0f0;
          border-radius: 4px;
        }

        .canvas-container {
          position: relative;
          border: 1px solid #ddd;
          border-radius: 4px;
          background: #fff;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .app__results.collapsed {
          height: 60px;
        }

        .app__results.collapsed .results-content {
          display: none;
        }

        @media (max-width: 1200px) {
          .side { width: 300px; }
          .results-table { font-size: 12px; }
          .results-table th, .results-table td { padding: 6px 4px; }
        }
      </style>
    </head>
    <body>
    <div id="loader"><div class="spinner"></div></div>
    <div class="app">
      <header class="app__header">
        <h1>NCPyVisual</h1>
      </header>
      <main class="app__main">
        <aside class="side">

            <div class="block">
              <h3>1) Import z terminala</h3>
              <div class="form-row">
                <label for="device-ip">Adres IP terminala</label>
                <input id="device-ip" type="text" placeholder="np. 172.16.3.13">
              </div>
              <div class="form-row">
                <label for="device-pass">Hasło (root)</label>
                <input id="device-pass" type="password" placeholder="jeśli wymagane">
              </div>
              <button id="btn-import" class="btn btn--primary">Pobierz konfigurację</button>
            </div>

            <div class="block">
              <h3>2) Galeria obrazów</h3>
              <div class="gallery-header">
                <div class="form-row" style="margin: 0; flex: 1;">
                  <label for="image-count">Ilość z terminala</label>
                  <input id="image-count" type="number" min="1" max="50" value="5">
                </div>
                <div class="gallery-stats" id="gallery-stats">0 obrazów</div>
              </div>

              <button id="btn-fetch" class="btn btn--primary">🔥 Pobierz z terminala</button>

              <div class="drop-zone" id="drop-zone">
                <div class="drop-zone-text">
                  🖼️ Przeciągnij pliki JPG/PNG tutaj<br>
                  lub <strong>kliknij aby wybrać</strong>
                </div>
              </div>
              <input id="image-input" type="file" accept=".jpg,.jpeg,.png" multiple>

              <div id="gallery" class="gallery">
                <div class="gallery-empty">
                  Brak obrazów w galerii<br>
                  <small>Dodaj obrazy z terminala lub z dysku</small>
                </div>
              </div>

              <div style="display: flex; gap: 4px; margin-top: 8px;">
                <button id="btn-clear-gallery" class="btn btn--muted" style="flex: 1;">🗑️ Wyczyść wszystkie</button>
                <button id="btn-select-all" class="btn btn--muted" style="flex: 1;">☑️ Zaznacz wszystkie</button>
              </div>
            </div>

            <div class="block">
              <h3>3) Obraz roboczy & ROI</h3>
              <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                Wybierz obraz z galerii lub wczytaj nowy do pracy z ROI
              </div>
              <label for="xml-input" class="filelike">📄 Wczytaj ROI z XML</label>
              <input id="xml-input" type="file" accept=".xml">
              <button id="btn-draw" class="btn">✏️ Rysuj ROI</button>
              <button id="btn-clear" class="btn btn--muted">🗑️ Wyczyść ROI</button>
            </div>

          <div class="block">
            <h3>4) Konfiguracja</h3>
            <div class="form-row"><label for="serial-number">Numer seryjny</label><input id="serial-number" type="text" placeholder="np. 593-072-73194"></div>
            <div class="form-row"><label for="location-id">ID Lokalizacji</label><input id="location-id" type="text" placeholder="np. WSC.3.069"></div>
            <div class="form-row"><label for="gps-lat">Szer. geogr.</label><input id="gps-lat" type="text" placeholder="51.2533333"></div>
            <div class="form-row"><label for="gps-lon">Dł. geogr.</label><input id="gps-lon" type="text" placeholder="22.5478611"></div>
            <div class="panel-title">Zaawansowane</div>
            <div class="form-row"><label for="backend-addr">Adres fotoradaru</label><input id="backend-addr" type="text" placeholder="np. 172.20.2.23"></div>
            <div class="form-row"><label for="swdallow-masks">SWD Allow</label><input id="swdallow-masks" type="text" placeholder="172.16.0.0/24 ..."></div>
            <div class="form-row"><label for="nativeallow-masks">Native Allow</label><input id="nativeallow-masks" type="text" placeholder="0.0.0.0/0"></div>
          </div>

          <div id="panel-props" class="block" style="display:none;">
            <h3>Właściwości ROI</h3>
            <div class="form-row"><label for="roi-id">ID</label><input id="roi-id" type="text" readonly></div>
            <div class="form-row"><label>Kąt</label><input class="param-input" data-param="angle" id="param-angle" type="number" step="0.1"></div>
            <div class="form-row"><label>Zoom</label><input class="param-input" data-param="zoom" id="param-zoom" type="number" step="0.01"></div>
            <div class="form-row"><label>Offset H</label><input class="param-input" data-param="reflexOffsetH" id="param-oh" type="number"></div>
            <div class="form-row"><label>Offset V</label><input class="param-input" data-param="reflexOffsetV" id="param-ov" type="number"></div>
            <div class="form-row"><label>Skew H</label><input class="param-input" data-param="skewH" id="param-sh" type="number" step="0.01"></div>
            <div class="form-row"><label>Skew V</label><input class="param-input" data-param="skewV" id="param-sv" type="number" step="0.01"></div>
            <button id="btn-edit" class="btn btn--warn">✏️ Edytuj kształt</button>
          </div>

          <div class="block">
            <h3>5) NCShot</h3>
            <button id="btn-ncshot" class="btn btn--success">🚀 Uruchom NCShot</button>
            <button id="btn-debug" class="btn btn--debug">🛠 Debug NCShot</button>
            <div style="display: flex; gap: 4px; margin-top: 8px;">
              <button id="btn-memory-monitor" class="btn btn--debug" style="flex: 1;">🧠 Monitor pamięci</button>
              <button id="btn-optimize-memory" class="btn btn--warn" style="flex: 1;">💾 Optymalizuj pamięć</button>
            </div>
            <div class="panel-title">🔥 Eksport sceny</div>
            <button id="btn-export-ini" class="btn btn--primary">📄 Zapisz scenę INI</button>

            <div style="font-size: 11px; color: #666; margin-top: 8px; padding: 6px; background: #f9f9f9; border-radius: 4px;">
              <strong>💡 Eksport:</strong><br>
              📄 <strong>INI</strong> - Gotowa konfiguracja z ROI
            </div>
          </div>

        </aside>

        <section class="content">
          <!-- Kontrolki obrazu -->
          <div class="image-controls">
            <button id="btn-zoom-in" title="Powiększ">🔍+</button>
            <button id="btn-zoom-out" title="Pomniejsz">🔍-</button>
            <button id="btn-zoom-fit" title="Dopasuj do okna">🔍</button>
            <button id="btn-zoom-100" title="100%">1:1</button>
            <button id="btn-pan-reset" title="Wycentruj">⌖</button>
            <div class="zoom-info" id="zoom-info">Brak obrazu</div>
          </div>

          <div class="canvas-wrapper">
            <div class="canvas-container">
              <canvas id="image-canvas"></canvas>
            </div>
          </div>
        </section>
      </main>

      <section class="app__results" id="results-panel" style="display: none;">
        <div class="results-panel">
          <div class="results-header">
            <span>📊 Wyniki NCShot</span>
            <button class="results-toggle" id="results-toggle">⬇️ Zwiń</button>
          </div>
          <div class="results-stats" id="results-stats-panel">
            Brak wyników do wyświetlenia
          </div>
          <div class="results-content" id="results-content-panel">
            <div class="results-table-container">
              <table class="results-table" id="results-table">
                <thead>
                  <tr>
                    <th>Plik</th>
                    <th>Pojazd</th>
                    <th>Tablica</th>
                    <th>Kraj</th>
                    <th>Poziom</th>
                    <th>Typ</th>
                    <th>Marka</th>
                    <th>Model</th>
                    <th>Kolor</th>
                    <th>MMR Div.</th>
                    <th>Obrazek tablicy</th>
                  </tr>
                </thead>
                <tbody id="results-table-body">
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
    </div>

    <script>
      console.log('🚀 Uruchamianie NCPyVisual...');

      const notyf = new Notyf({ duration: 4000, position: { x:'right', y:'top' }});
      let canvas, drawing=false, editPoly=null, tmpPts=[], tmpDots=[], roiCount=0;

      let galleryImages = [];
      let nextImageId = 1;
      let currentWorkingImage = null;
      let currentZoom = 1;
      let isPanning = false;
      let lastPosX = 0;
      let lastPosY = 0;

      // 🔧 KLUCZOWE ZMIENNE DLA POPRAWNEGO SKALOWANIA ROI
      let originalImageWidth = 0;  // Szerokość oryginalnego obrazu
      let originalImageHeight = 0; // Wysokość oryginalnego obrazu
      let displayScale = 1;        // Skala wyświetlania (canvas/oryginalny obraz)

      // 🔧 NOWA ZMIENNA: przechowuje ROI w oczekiwaniu na obraz roboczy
      let pendingRois = [];

      // 🔧 FUNKCJA DYNAMICZNEGO POBIERANIA NAZW PLIKÓW (zamiast przechowywania w pamięci)
      function getCurrentImageFilenames() {
        return getActiveImages().map(img => img.filename);
      }

      const roiColors = [
        { fill:'rgba(0,255,0,.3)', stroke:'green' },
        { fill:'rgba(255,255,0,.3)', stroke:'orange' },
        { fill:'rgba(255,0,255,.3)', stroke:'magenta' },
        { fill:'rgba(0,255,255,.3)', stroke:'cyan' },
        { fill:'rgba(255,165,0,.3)', stroke:'darkorange' },
      ];

      const $ = (id)=>document.getElementById(id);
      const $loader = $('loader');
      const showLoader = ()=> $loader.style.display='flex';
      const hideLoader = ()=> $loader.style.display='none';

      document.addEventListener('DOMContentLoaded', ()=>{
        console.log('📱 DOM załadowany, inicjalizacja...');

        try {
          canvas = new fabric.Canvas('image-canvas');
          console.log('✅ Canvas utworzony');

          bindUI();
          console.log('✅ UI przypisane');

          setupDragAndDrop();
          console.log('✅ Drag&Drop skonfigurowany');

          setupResultsPanel();
          console.log('✅ Panel wyników skonfigurowany');

          setupImageNavigation();
          console.log('✅ Nawigacja obrazu skonfigurowana');

          console.log('🎉 Inicjalizacja zakończona pomyślnie!');
          notyf.success('NCPyVisual załadowany pomyślnie!');

        } catch (error) {
          console.error('⚠️ Błąd inicjalizacji:', error);
          notyf.error('Błąd inicjalizacji: ' + error.message);
        }
      });

      function bindUI(){
        console.log('🔗 Przypisywanie eventów UI...');

        try {
          $('btn-import').onclick = importFromDevice;
          $('btn-fetch').onclick = fetchImages;
          $('btn-export-ini').onclick = exportSceneINI;
          $('btn-draw').onclick = startDraw;
          $('btn-clear').onclick = clearRoi;
          $('btn-edit').onclick = toggleEdit;
          $('btn-ncshot').onclick = runNcshotProfessional;
          $('btn-debug').onclick = debugNcshot;
          $('btn-memory-monitor').onclick = monitorMemoryUsage;
          $('btn-optimize-memory').onclick = optimizeGalleryMemory;
          $('image-input').onchange = loadImagesFromDisk;
          $('btn-clear-gallery').onclick = clearGallery;
          $('btn-select-all').onclick = selectAllImages;
          $('drop-zone').onclick = () => $('image-input').click();

          $('xml-input').onchange = loadXml;

          canvas.on('mouse:down', onMouseDown);
          canvas.on('selection:created', onSelect);
          canvas.on('selection:updated', onSelect);
          canvas.on('selection:cleared', onClearSel);

          document.querySelectorAll('.param-input').forEach(inp=>{
            inp.addEventListener('input', onParamChange);
          });

          document.addEventListener('keydown', (e)=>{
            if(document.activeElement.tagName==='INPUT') return;
            if(e.key==='Delete' || e.key==='Backspace') deleteRoi(false);
            if(e.key==='f' || e.key==='F') fitRoiToImage();
            if(e.key==='d' || e.key==='D') debugRoi();
            if(e.key==='r' || e.key==='R') createDefaultRoi();
          });

          const cc = document.querySelector('.canvas-container');
          if(cc) cc.addEventListener('contextmenu', (e)=>{ e.preventDefault(); if(drawing) finishPolygon(); });

          console.log('✅ Wszystkie eventy przypisane');
        } catch (error) {
          console.error('⚠️ Błąd przypisywania UI:', error);
        }
      }

      function setupImageNavigation() {
        $('btn-zoom-in').onclick = () => zoomCanvas(1.2);
        $('btn-zoom-out').onclick = () => zoomCanvas(0.8);
        $('btn-zoom-fit').onclick = fitToWindow;
        $('btn-zoom-100').onclick = () => setZoom(1);
        $('btn-pan-reset').onclick = resetPan;

        // Zoom kółkiem myszy
        canvas.on('mouse:wheel', function(opt) {
          if(!currentWorkingImage) return;
          opt.e.preventDefault();
          opt.e.stopPropagation();

          const delta = opt.e.deltaY;
          let zoom = canvas.getZoom();
          zoom *= 0.999 ** delta;

          if (zoom > 5) zoom = 5;
          if (zoom < 0.1) zoom = 0.1;

          const point = new fabric.Point(opt.e.offsetX, opt.e.offsetY);
          canvas.zoomToPoint(point, zoom);
          updateZoomInfo();
        });

        // Przesuwanie obrazu
        canvas.on('mouse:down', function(opt) {
          if(!currentWorkingImage) return;

          // Jeśli nie rysujemy ROI i kliknięto poza obiektem
          if(!drawing && !canvas.getActiveObject() && opt.e.altKey) {
            isPanning = true;
            canvas.isDragging = true;
            canvas.selection = false;
            lastPosX = opt.e.clientX;
            lastPosY = opt.e.clientY;
            canvas.defaultCursor = 'grabbing';
            canvas.setCursor('grabbing');
          }
        });

        canvas.on('mouse:move', function(opt) {
          if (isPanning && canvas.isDragging) {
            const vpt = canvas.viewportTransform;
            vpt[4] += opt.e.clientX - lastPosX;
            vpt[5] += opt.e.clientY - lastPosY;
            canvas.requestRenderAll();
            lastPosX = opt.e.clientX;
            lastPosY = opt.e.clientY;
          }
        });

        canvas.on('mouse:up', function(opt) {
          if (isPanning) {
            canvas.setViewportTransform(canvas.viewportTransform);
            canvas.isDragging = false;
            canvas.selection = true;
            isPanning = false;
            canvas.defaultCursor = 'default';
            canvas.setCursor('default');
          }
        });
      }

      function zoomCanvas(factor) {
        if(!currentWorkingImage) return;
        const zoom = canvas.getZoom() * factor;
        if (zoom > 5) return;
        if (zoom < 0.1) return;

        const center = canvas.getCenter();
        canvas.zoomToPoint(new fabric.Point(center.left, center.top), zoom);
        updateZoomInfo();
      }

      function setZoom(zoom) {
        if(!currentWorkingImage) return;
        const center = canvas.getCenter();
        canvas.zoomToPoint(new fabric.Point(center.left, center.top), zoom);
        updateZoomInfo();
      }

      function fitToWindow() {
        if(!currentWorkingImage) return;

        const wrapper = document.querySelector('.canvas-wrapper');
        const availableWidth = wrapper.clientWidth - 40;
        const availableHeight = wrapper.clientHeight - 40;

        const img = canvas.backgroundImage;
        if(!img) return;

        const imgWidth = originalImageWidth;
        const imgHeight = originalImageHeight;

        const scaleX = availableWidth / imgWidth;
        const scaleY = availableHeight / imgHeight;
        const scale = Math.min(scaleX, scaleY);

        canvas.setWidth(imgWidth * scale);
        canvas.setHeight(imgHeight * scale);
        canvas.setZoom(1);
        canvas.absolutePan(new fabric.Point(0, 0));

        // 🔧 AKTUALIZUJ DISPLAY SCALE
        displayScale = scale;

        updateZoomInfo();
      }

      function resetPan() {
        if(!currentWorkingImage) return;
        canvas.absolutePan(new fabric.Point(0, 0));
        canvas.setZoom(1);
        updateZoomInfo();
      }

      function updateZoomInfo() {
        const zoomInfo = $('zoom-info');
        if(currentWorkingImage) {
          const zoom = (canvas.getZoom() * 100).toFixed(0);
          const scaleText = displayScale < 1 ? `Scale: ${displayScale.toFixed(3)}` : 'Scale: 1:1';
          zoomInfo.textContent = `${zoom}% | ${scaleText} | Alt+przeciągnij = przesuwanie`;
        } else {
          zoomInfo.textContent = 'Brak obrazu';
        }
      }

      function setupResultsPanel() {
        const resultsToggle = $('results-toggle');
        const resultsPanel = $('results-panel');

        resultsToggle.onclick = () => {
          resultsPanel.classList.toggle('collapsed');
          resultsToggle.textContent = resultsPanel.classList.contains('collapsed') ? '⬆️ Rozwiń' : '⬇️ Zwiń';
        };
      }

      function setupDragAndDrop() {
        const dropZone = $('drop-zone');
        const gallery = $('gallery');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
          dropZone.addEventListener(eventName, preventDefaults, false);
          gallery.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
          dropZone.addEventListener(eventName, highlight, false);
          gallery.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
          dropZone.addEventListener(eventName, unhighlight, false);
          gallery.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
          e.target.classList.add('drag-over');
        }

        function unhighlight(e) {
          e.target.classList.remove('drag-over');
        }

        dropZone.addEventListener('drop', handleDrop, false);
        gallery.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;
          processFiles(files);
        }
      }

      function processFiles(files) {
        [...files].forEach(file => {
          if (file.type.startsWith('image/')) {
            addImageToGallery(file);
          }
        });
      }

      function addImageToGallery(file, source = 'disk') {
        const reader = new FileReader();
        reader.onload = (e) => {
          const imageData = e.target.result;

          // 🔧 WALIDACJA ROZMIARU OBRAZU Z DYSKU
          const maxSize = 5 * 1024 * 1024; // 5MB
          if (file.size > maxSize) {
            notyf.error(`Obraz "${file.name}" jest za duży (${Math.round(file.size/1024/1024)}MB). Maksymalny rozmiar: 5MB`);
            return;
          }

          console.log(`🔍 Wczytywanie z dysku: ${file.name}, rozmiar: ${Math.round(file.size/1024)}KB`);

          // 🔧 KOMPRESJA OBRAZÓW Z DYSKU dla NCShot
          if (file.size > 1024 * 1024) { // Jeśli >1MB, skompresuj
            console.log(`🗜️ Kompresja obrazu ${file.name} dla NCShot...`);
            compressImageForNCShot(imageData, file.name, (compressedData, compressedSize) => {
              const imageObj = {
                id: nextImageId++,
                filename: file.name || `obraz_${Date.now()}.jpg`,
                data: compressedData,
                size: compressedSize,
                source: source,
                active: true,
                originalSize: file.size // Zachowaj oryginalny rozmiar
              };

              galleryImages.push(imageObj);
              updateGalleryDisplay();
              notyf.success(`Dodano: ${imageObj.filename} (${Math.round(file.size/1024)}KB → ${Math.round(compressedSize/1024)}KB)`);
              console.log(`🔍 Dodano obraz z dysku (skompresowany): ${imageObj.filename}, ${Math.round(compressedSize/1024)}KB`);
            });
          } else {
            const imageObj = {
              id: nextImageId++,
              filename: file.name || `obraz_${Date.now()}.jpg`,
              data: imageData,
              size: file.size || 0,
              source: source,
              active: true
            };

            galleryImages.push(imageObj);
            updateGalleryDisplay();
            notyf.success(`Dodano: ${imageObj.filename} (${Math.round(file.size/1024)}KB)`);
            console.log(`🔍 Dodano obraz z dysku: ${imageObj.filename}, rozmiar: ${Math.round(file.size/1024)}KB`);
          }
        };
        reader.readAsDataURL(file);
      }

      // 🔧 NOWA FUNKCJA: Kompresja obrazów dla NCShot
      function compressImageForNCShot(imageDataUrl, filename, callback) {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Zachowaj wymiary jeśli są rozsądne, inaczej przeskaluj
          let { width, height } = img;
          const maxDimension = 2048; // Maksymalny wymiar dla NCShot

          if (width > maxDimension || height > maxDimension) {
            const scale = maxDimension / Math.max(width, height);
            width = Math.floor(width * scale);
            height = Math.floor(height * scale);
            console.log(`🗜️ Przeskalowanie ${filename}: ${img.width}x${img.height} → ${width}x${height}`);
          }

          canvas.width = width;
          canvas.height = height;

          // Narysuj obraz z kompresją
          ctx.drawImage(img, 0, 0, width, height);

          // Konwertuj do JPEG z kompresją 0.8 (dobry balans jakości/rozmiaru)
          const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.8);

          // Oblicz przybliżony rozmiar
          const compressedSize = Math.round((compressedDataUrl.length * 3) / 4); // base64 to bytes

          callback(compressedDataUrl, compressedSize);
        };
        img.src = imageDataUrl;
      }

      function addBase64ImageToGallery(filename, dataUrl, size, source = 'terminal') {
        const imageObj = {
          id: nextImageId++,
          filename: filename,
          data: dataUrl,
          size: size || 0,
          source: source,
          active: true  // 🔧 POPRAWKA: automatycznie aktywuj obrazy z terminala
        };

        galleryImages.push(imageObj);
        updateGalleryDisplay();
        console.log(`📡 Dodano obraz z terminala: ${imageObj.filename}, active: ${imageObj.active}`);
      }

      function updateGalleryDisplay() {
        const gallery = $('gallery');
        const stats = $('gallery-stats');

        const activeCount = galleryImages.filter(img => img.active).length;
        stats.textContent = `${galleryImages.length} obrazów (${activeCount} zaznaczonych)`;

        if (galleryImages.length === 0) {
          gallery.innerHTML = `
            <div class="gallery-empty">
              Brak obrazów w galerii<br>
              <small>Dodaj obrazy z terminala lub z dysku</small>
            </div>
          `;
          return;
        }

        gallery.innerHTML = '';

        galleryImages.forEach((img, index) => {
          const item = document.createElement('div');
          item.className = `gallery-item ${img.active ? 'active' : ''}`;

          const thumb = document.createElement('img');
          thumb.className = 'gallery-thumb';
          thumb.src = img.data;
          thumb.title = 'Kliknij aby ustawić jako obraz roboczy';
          thumb.onclick = () => setWorkingImage(img);

          const info = document.createElement('div');
          info.className = 'gallery-info';

          const filename = document.createElement('div');
          filename.className = 'gallery-filename';
          filename.textContent = img.filename;
          filename.title = img.filename;

          const details = document.createElement('div');
          details.className = 'gallery-details';
          const sizeKB = Math.round(img.size / 1024);
          details.textContent = `${img.source} • ${sizeKB}KB • ID:${img.id}`;

          info.appendChild(filename);
          info.appendChild(details);

          const actions = document.createElement('div');
          actions.className = 'gallery-actions';

          const toggleBtn = document.createElement('button');
          toggleBtn.className = `btn btn--small ${img.active ? 'btn--success' : 'btn--muted'}`;
          toggleBtn.textContent = img.active ? '☑️' : '☐';
          toggleBtn.title = img.active ? 'Odznacz z przetwarzania' : 'Zaznacz do przetwarzania';
          toggleBtn.onclick = () => toggleImageActive(img.id);

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'btn btn--small btn--danger';
          deleteBtn.textContent = '🗑️';
          deleteBtn.title = 'Usuń obraz';
          deleteBtn.onclick = () => removeImageFromGallery(img.id);

          actions.appendChild(toggleBtn);
          actions.appendChild(deleteBtn);

          item.appendChild(thumb);
          item.appendChild(info);
          item.appendChild(actions);

          gallery.appendChild(item);
        });
      }

      // 🔧 NAPRAWIONA FUNKCJA USTAWIANIA OBRAZU ROBOCZEGO
      function setWorkingImage(imageObj) {
        console.log(`🖼️ Ustawianie obrazu roboczego: ${imageObj.filename}`);
        currentWorkingImage = imageObj;

        fabric.Image.fromURL(imageObj.data, (img) => {
          // 🔧 ZAPISZ ORYGINALNE WYMIARY OBRAZU
          originalImageWidth = img.width;
          originalImageHeight = img.height;

          console.log(`🔍 Wymiary oryginalnego obrazu: ${originalImageWidth}x${originalImageHeight}`);

          const wrapper = document.querySelector('.canvas-wrapper');
          const availableWidth = wrapper.clientWidth - 40;
          const availableHeight = wrapper.clientHeight - 40;

          // 🔧 OBLICZ NOWĄ SKALĘ WYŚWIETLANIA
          const scaleX = availableWidth / originalImageWidth;
          const scaleY = availableHeight / originalImageHeight;
          displayScale = Math.min(scaleX, scaleY, 1);

          const displayWidth = Math.floor(originalImageWidth * displayScale);
          const displayHeight = Math.floor(originalImageHeight * displayScale);

          console.log(`🎯 Nowa skala wyświetlania: ${displayScale.toFixed(3)}`);
          console.log(`🎯 Canvas: ${displayWidth}x${displayHeight}`);

          // Ustaw rozmiar canvas
          canvas.setWidth(displayWidth);
          canvas.setHeight(displayHeight);

          // Wyczyść canvas
          canvas.clear();

          // Ustaw obraz jako tło
          canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
            originX: 'left',
            originY: 'top',
            scaleX: displayScale,
            scaleY: displayScale
          });

          // 🔧 IMPORTUJ ROI - sprawdź czy są oczekujące ROI do zastosowania
          if (pendingRois.length > 0) {
            console.log(`🔧 Zastosowanie ${pendingRois.length} oczekujących ROI`);
            drawRoisFromOriginalScale(pendingRois);
            // NIE czyść pendingRois - zostaw dla kolejnych obrazów
            notyf.success(`Zastosowano ${pendingRois.length} ROI na obrazie roboczym`);
          } else {
            // Sprawdź czy są ROI już na canvas do przeniesienia
            const existingRois = roisOut();
            if (existingRois.length > 0) {
              console.log(`🔧 Przywracam ${existingRois.length} ROI z canvas`);
              drawRoisFromOriginalScale(existingRois);
            }
          }

          // Reset nawigacji
          canvas.setZoom(1);
          canvas.absolutePan(new fabric.Point(0, 0));

          canvas.renderAll();
          updateZoomInfo();

          console.log(`✅ Obraz ustawiony! Canvas: ${displayWidth}x${displayHeight}`);
          notyf.success(`Obraz roboczy: ${imageObj.filename}`);
        });
      }

      function toggleImageActive(imageId) {
        const img = galleryImages.find(i => i.id === imageId);
        if (img) {
          img.active = !img.active;
          updateGalleryDisplay();
        }
      }

      function removeImageFromGallery(imageId) {
        const img = galleryImages.find(i => i.id === imageId);
        if (img && confirm(`Usunąć obraz "${img.filename}"?`)) {
          console.log(`🗑️ Usuwanie obrazu: ${img.filename} (ID:${imageId})`);

          galleryImages = galleryImages.filter(i => i.id !== imageId);
          updateGalleryDisplay();

          console.log(`📊 Stan galerii po usunięciu:`, galleryImages.map(i => `${i.filename} (ID:${i.id}, active:${i.active})`));

          notyf.success('Usunięto obraz');
        }
      }

      function clearGallery() {
        if (galleryImages.length === 0) return;
        if (confirm(`Usunąć wszystkie ${galleryImages.length} obrazów z galerii?`)) {
          console.log(`🗑️ Czyszczenie całej galerii: ${galleryImages.length} obrazów`);

          galleryImages = [];
          currentWorkingImage = null;
          pendingRois = []; // Wyczyść oczekujące ROI
          canvas.clear();
          updateZoomInfo();
          updateGalleryDisplay();

          console.log(`📊 Stan po wyczyszczeniu: galeria=${galleryImages.length}, currentWorkingImage=${currentWorkingImage}, pendingRois=${pendingRois.length}`);

          notyf.success('Wyczyszczono galerię');
        }
      }

      function selectAllImages() {
        if (galleryImages.length === 0) return;

        const allActive = galleryImages.every(img => img.active);
        galleryImages.forEach(img => img.active = !allActive);
        updateGalleryDisplay();

        const action = allActive ? 'Odznaczono' : 'Zaznaczono';
        notyf.success(`${action} wszystkie obrazy`);
      }

      function loadImagesFromDisk(ev) {
        const files = ev.target.files;
        if (!files || files.length === 0) return;

        console.log(`🔍 Wczytywanie ${files.length} plików z dysku...`);
        processFiles(files);

        ev.target.value = '';
      }

      function getActiveImages() {
        return galleryImages.filter(img => img.active);
      }

      function getActiveImageData() {
        return galleryImages.filter(img => img.active).map(img => img.data);
      }

      function startDraw(){
        console.log('✏️ Rozpoczynam rysowanie ROI...');
        if(editPoly) toggleEdit();
        drawing = true; canvas.selection = false;
        $('btn-draw').disabled = true; $('btn-draw').textContent = 'Rysowanie… (PPM kończy)';
      }

      function onMouseDown(opt){
        if(!drawing) return;
        if(opt.e.button !== 0) return;
        if(opt.e.altKey) return; // Nie rysuj podczas przesuwania

        const p = canvas.getPointer(opt.e);
        tmpPts.push({x:p.x, y:p.y});
        const dot = new fabric.Circle({ left:p.x, top:p.y, radius:3, fill:'red', selectable:false, originX:'center', originY:'center' });
        canvas.add(dot); tmpDots.push(dot); canvas.renderAll();
      }

      function finishPolygon(){
        if(tmpPts.length < 3){ resetDraw(); return; }
        const color = roiColors[roiCount % roiColors.length]; roiCount++;
        const poly = new fabric.Polygon(tmpPts, {
          fill: color.fill, stroke: color.stroke, strokeWidth:2, selectable:true, hasControls:true,
          customData: { id:`ROI-${roiCount}`, angle:0, zoom:1, reflexOffsetH:0, reflexOffsetV:0, skewH:0, skewV:0 }
        });
        canvas.add(poly); resetDraw();
        console.log(`✅ Utworzono ROI-${roiCount}`);
      }

      function resetDraw(){
        tmpDots.forEach(d=>canvas.remove(d)); tmpDots=[]; tmpPts=[]; drawing=false; canvas.selection = true;
        $('btn-draw').disabled=false; $('btn-draw').textContent='✏️ Rysuj ROI'; canvas.renderAll();
      }

      function onSelect(e){
        if(editPoly) toggleEdit();
        const o = e.selected[0];
        if(o && o.customData){
          $('panel-props').style.display='block';
          $('roi-id').value = o.customData.id || '';
          document.querySelectorAll('.param-input').forEach(inp=>{
            const k = inp.dataset.param; inp.value = o.customData[k] ?? 0;
          });
        } else $('panel-props').style.display='none';
      }
      function onClearSel(){ if(editPoly) toggleEdit(); $('panel-props').style.display='none'; }
      function onParamChange(e){
        const o = canvas.getActiveObject(); if(!(o&&o.customData)) return;
        const k = e.target.dataset.param; o.customData[k] = parseFloat(e.target.value) || 0;
      }

      function deleteRoi(confirmFirst){
        const o = canvas.getActiveObject(); if(!o){ if(confirmFirst) notyf.error('Nie zaznaczono ROI'); return; }
        if(confirmFirst && !confirm(`Usunąć ${o.customData.id}?`)) return;
        canvas.remove(o); notyf.success('Usunięto ROI'); canvas.renderAll();
      }

      function toggleEdit(){
        const btn = $('btn-edit');
        if(editPoly){
          editPoly.edit = false; canvas.setActiveObject(editPoly); btn.textContent='✏️ Edytuj kształt'; btn.className='btn btn--warn';
          editPoly = null; canvas.renderAll();
        } else {
          const o = canvas.getActiveObject();
          if(!(o && o.type==='polygon')){ notyf.error('Zaznacz poligon'); return; }
          editPoly = o; editPoly.edit = true; btn.textContent='✅ Zatwierdź'; btn.className='btn btn--primary';
          canvas.setActiveObject(editPoly); canvas.renderAll();
        }
      }

      function clearRoi(){
        if(!confirm('Wyczyścić wszystkie ROI?')) return;
        canvas.getObjects().filter(o=>o.customData).forEach(o=>canvas.remove(o));
        roiCount=0;
        pendingRois = []; // Wyczyść też oczekujące ROI
        canvas.renderAll();
        notyf.success('Wyczyszczono ROI');
      }

      // 🔧 POPRAWIONA FUNKCJA EKSPORTU ROI - KONWERSJA DO ORYGINALNEJ SKALI
      function roisOut(){
        return canvas.getObjects().filter(o=>o.customData).map(o=>{
          // 🔧 KONWERTUJ PUNKTY Z DISPLAY SCALE DO ORYGINALNEJ SKALI OBRAZU
          const originalPoints = o.points.map(point => ({
            x: point.x / displayScale,
            y: point.y / displayScale
          }));

          console.log(`🔧 ROI ${o.customData.id}: Display points:`, o.points.slice(0,2), '-> Original points:', originalPoints.slice(0,2));

          return {
            ...o.customData,
            points: originalPoints
          };
        });
      }

      // 🔧 FUNKCJA: RYSUJ ROI Z ORYGINALNEJ SKALI NA DISPLAY SCALE
      function drawRoisFromOriginalScale(roisInOriginalScale) {
        // Wyczyść istniejące ROI
        canvas.getObjects().filter(o=>o.customData).forEach(o=>canvas.remove(o));

        if (!originalImageWidth || !originalImageHeight || !displayScale) {
          console.warn('🔧 Brak danych obrazu do konwersji ROI');
          return;
        }

        roisInOriginalScale.forEach((r,i)=>{
          const color = roiColors[i % roiColors.length];

          // 🔧 KONWERTUJ Z ORYGINALNEJ SKALI DO DISPLAY SCALE
          let points;
          if (r.points && r.points.length >= 3) {
            points = r.points.map(p => ({
              x: p.x * displayScale,
              y: p.y * displayScale
            }));
            console.log(`🔧 ROI ${r.id}: Oryginalny punkt ${r.points[0].x.toFixed(0)},${r.points[0].y.toFixed(0)} -> Display ${points[0].x.toFixed(1)},${points[0].y.toFixed(1)}`);
          } else {
            // Domyślne ROI w display scale
            const w = canvas.width || 800;
            const h = canvas.height || 600;
            const roiWidth = w * 0.5;
            const roiHeight = h * 0.3;
            const startX = (w - roiWidth) / 2 + (i * 30);
            const startY = (h - roiHeight) / 2 + (i * 20);

            points = [
              {x: startX, y: startY},
              {x: startX + roiWidth, y: startY},
              {x: startX + roiWidth, y: startY + roiHeight},
              {x: startX, y: startY + roiHeight}
            ];
          }

          const cd = {...r}; delete cd.points;
          const poly = new fabric.Polygon(points, {
            fill:color.fill,
            stroke:color.stroke,
            strokeWidth:2,
            selectable:true,
            hasControls:true,
            customData:cd
          });
          canvas.add(poly);
        });

        roiCount = roisInOriginalScale.length;
        canvas.renderAll();
        console.log(`🔧 Zaimportowano ${roisInOriginalScale.length} ROI z oryginalnej skali do display scale ${displayScale.toFixed(3)}`);
      }

      // 🔧 FUNKCJA: RYSUJ ROI Z DOMYŚLNĄ SKALĄ (gdy nie ma obrazu roboczego)
      function drawRoisWithDefaultScale(list) {
        // Wyczyść istniejące ROI
        canvas.getObjects().filter(o=>o.customData).forEach(o=>canvas.remove(o));

        // Ustaw domyślny rozmiar canvas jeśli jest pusty
        if (canvas.width <= 1 || canvas.height <= 1) {
          canvas.setWidth(800);
          canvas.setHeight(600);
        }

        list.forEach((r,i)=>{
          const color = roiColors[i % roiColors.length];

          let points;
          if (r.points && r.points.length >= 3) {
            // Użyj oryginalnych punktów, ale przeskaluj jeśli są za duże
            const maxX = Math.max(...r.points.map(p => p.x));
            const maxY = Math.max(...r.points.map(p => p.y));

            if (maxX > canvas.width || maxY > canvas.height) {
              // Przeskaluj do canvas
              const scaleX = canvas.width * 0.8 / maxX;
              const scaleY = canvas.height * 0.8 / maxY;
              const scale = Math.min(scaleX, scaleY);

              points = r.points.map(p => ({
                x: p.x * scale + canvas.width * 0.1,
                y: p.y * scale + canvas.height * 0.1
              }));
            } else {
              points = r.points;
            }
          } else {
            // Domyślne ROI
            const w = canvas.width;
            const h = canvas.height;
            const roiWidth = w * 0.5;
            const roiHeight = h * 0.3;
            const startX = (w - roiWidth) / 2 + (i * 30);
            const startY = (h - roiHeight) / 2 + (i * 20);

            points = [
              {x: startX, y: startY},
              {x: startX + roiWidth, y: startY},
              {x: startX + roiWidth, y: startY + roiHeight},
              {x: startX, y: startY + roiHeight}
            ];
          }

          const cd = {...r}; delete cd.points;
          const poly = new fabric.Polygon(points, {
            fill:color.fill,
            stroke:color.stroke,
            strokeWidth:2,
            selectable:true,
            hasControls:true,
            customData:cd
          });
          canvas.add(poly);
        });

        roiCount = list.length;
        canvas.renderAll();
        console.log(`🔧 ROI wyświetlone z domyślną skalą na canvas ${canvas.width}x${canvas.height}`);
      }

      // 🔧 FUNKCJA IMPORTU ROI - ZAWSZE WIDOCZNE + SMART SCALING
      function drawRois(list){
        if (!list || list.length === 0) {
          canvas.getObjects().filter(o=>o.customData).forEach(o=>canvas.remove(o));
          canvas.renderAll();
          pendingRois = []; // Wyczyść oczekujące
          return;
        }

        console.log(`🔧 Import ${list.length} ROI - zawsze widoczne + smart scaling`);

        // 🔧 KONWERTUJ WSZYSTKIE ROI DO ORYGINALNEJ SKALI OBRAZU
        const roisInOriginalScale = list.map((r, i) => {
          if (!r.points || r.points.length < 3) {
            // Stwórz domyślne ROI w oryginalnej skali
            const defaultWidth = originalImageWidth || 2560;
            const defaultHeight = originalImageHeight || 1920;
            return {
              ...r,
              points: [
                {x: defaultWidth * 0.2, y: defaultHeight * 0.3},
                {x: defaultWidth * 0.8, y: defaultHeight * 0.3},
                {x: defaultWidth * 0.8, y: defaultHeight * 0.7},
                {x: defaultWidth * 0.2, y: defaultHeight * 0.7}
              ]
            };
          }

          const maxX = Math.max(...r.points.map(p => p.x));
          const maxY = Math.max(...r.points.map(p => p.y));

          let originalPoints;

          if (maxX <= 1.0 && maxY <= 1.0) {
            // 🔧 WSPÓŁRZĘDNE WZGLĘDNE (0-1) - KONWERTUJ NA ORYGINALNE PIKSELE
            const refWidth = originalImageWidth || 2560;
            const refHeight = originalImageHeight || 1920;
            originalPoints = r.points.map(p => ({
              x: p.x * refWidth,
              y: p.y * refHeight
            }));
            console.log(`🔧 ROI ${r.id}: konwersja z względnych (0-1) na oryginalne piksele`);
          } else {
            // 🔧 ZAŁOŻENIE: JUŻ W ORYGINALNEJ SKALI PIKSELI
            originalPoints = r.points;
            console.log(`🔧 ROI ${r.id}: traktuję jako oryginalne piksele`);
          }

          return {
            ...r,
            points: originalPoints
          };
        });

        // 🔧 ZAPISZ ROI w oryginalnej skali do późniejszego użycia
        pendingRois = roisInOriginalScale;

        // 🔧 ZAWSZE POKAŻ ROI OD RAZU (jak w starej wersji)
        if (currentWorkingImage && originalImageWidth && displayScale) {
          // Mamy obraz roboczy - użyj prawidłowej skali
          drawRoisFromOriginalScale(roisInOriginalScale);
          console.log(`🔧 ROI wyświetlone z prawidłową skalą ${displayScale.toFixed(3)}`);
        } else {
          // Brak obrazu roboczego - pokaż ROI z domyślną skalą
          drawRoisWithDefaultScale(list);
          console.log(`🔧 ROI wyświetlone z domyślną skalą (brak obrazu roboczego)`);
        }

        notyf.success(`Zaimportowano ${list.length} ROI`);
      }

      // 🔧 NOWA FUNKCJA: EKSPORT INI (zamiast XML i ZIP)
      async function exportSceneINI(){
        console.log('📄 Eksport sceny do INI...');
        if(editPoly) toggleEdit();

        const rois = roisOut();
        if(!rois.length) return notyf.error('Dodaj ROI przed eksportem INI');

        const deployment = {
          serialNumber: $('serial-number').value || '',
          locationId: $('location-id').value || '',
          gpsLat: $('gps-lat').value || '',
          gpsLon: $('gps-lon').value || '',
          backendAddr: $('backend-addr').value || '',
          swdallowMasks: $('swdallow-masks').value || '',
          nativeallowMasks: $('nativeallow-masks').value || ''
        };

        if(!deployment.locationId) return notyf.error('Wymagane ID lokalizacji do nazwy pliku INI');

        const packageData = {
          rois: rois,
          deployment: deployment
        };

        showLoader();
        try{
          const res = await fetch('/generate-package/', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify(packageData)
          });

          if(!res.ok) {
            const err = await res.json();
            throw new Error(err.detail || 'Błąd serwera');
          }

          // Pobierz ZIP (zawiera INI)
          const blob = await res.blob();
          const url = URL.createObjectURL(blob);

          // Utwórz link do pobrania z nazwą INI
          const a = document.createElement('a');
          a.href = url;
          a.download = `${deployment.locationId}_scene_${new Date().toISOString().slice(0,10)}.zip`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          notyf.success(`✅ Pobrano scenę: ${a.download}`);

        }catch(e){
          console.error('⚠️ Błąd eksportu INI:', e);
          notyf.error('Błąd eksportu INI: ' + e.message);
        }finally{
          hideLoader();
        }
      }

      async function importFromDevice(){
        console.log('🔥 Import z urządzenia...');
        const ip=$('device-ip').value, password=$('device-pass').value;
        if(!ip) return notyf.error('Podaj IP terminala');
        showLoader();
        try{
          const res = await fetch('/import-from-device/', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({ ip, password })
          });
          if(!res.ok){
            const e=await res.json();
            throw new Error(e.detail || 'Błąd importu');
          }
          const data = await res.json();

          $('serial-number').value = data.serialNumber || '';
          $('location-id').value = data.locationId || '';
          $('gps-lat').value = data.gpsLat || '';
          $('gps-lon').value = data.gpsLon || '';
          $('backend-addr').value = data.backendAddr || '';
          $('swdallow-masks').value = data.swdallowMasks || '';
          $('nativeallow-masks').value = data.nativeallowMasks || '';

          if(data.rois && data.rois.length){
            drawRois(data.rois);
            notyf.success(`Zaimportowano konfigurację z ${ip}`);
          } else {
            drawRois([]); // To wyczyści ROI i pendingRois
            notyf.success('Brak ROI na urządzeniu, wyczyszczono.');
          }
        }catch(e){
          notyf.error(e.message);
        }finally{
          hideLoader();
        }
      }

      // 🔧 NAPRAWIONA FUNKCJA fetchImages - automatycznie ustaw pierwszy obraz jako roboczy
      async function fetchImages(){
        console.log('🔥 Pobieranie obrazów z terminala...');
        const ip=$('device-ip').value, password=$('device-pass').value, count=parseInt($('image-count').value||'5',10);
        if(!ip) return notyf.error('Podaj IP terminala');

        showLoader();
        try{
          const res = await fetch('/fetch-device-images/', {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({ ip, password, count })
          });
          if(!res.ok){
            const e=await res.json();
            throw new Error(e.detail || 'Błąd');
          }
          const data = await res.json();
          if(data.images && data.images.length){
            data.images.forEach(it => {
              addBase64ImageToGallery(it.filename, it.data, it.size, 'terminal');
            });

            updateGalleryDisplay();

            // 🔧 NOWE: automatycznie ustaw pierwszy obraz jako roboczy jeśli nie ma obecnego
            if (!currentWorkingImage && galleryImages.length > 0) {
              const firstTerminalImage = galleryImages.find(img => img.source === 'terminal');
              if (firstTerminalImage) {
                console.log('🔧 Automatycznie ustawiam pierwszy obraz z terminala jako roboczy');
                setWorkingImage(firstTerminalImage);
              }
            }

            notyf.success(`Dodano ${data.images.length} obrazów z terminala do galerii`);
          } else {
            notyf.success('Brak zdjęć na urządzeniu.');
          }
        }catch(e){
          notyf.error(e.message);
        }finally{
          hideLoader();
        }
      }

      // 🔧 NAPRAWIONA FUNKCJA NCSHOT z zarządzaniem pamięcią
      async function runNcshotProfessional(){
          console.log('🚀 Uruchamianie NCShot z zarządzaniem pamięcią...');
          if(editPoly) toggleEdit();

          // 🔧 RESET STANU POPRZEDNICH WYNIKÓW
          const tableBody = $('results-table-body');
          if (tableBody) {
            tableBody.innerHTML = '';
            console.log('🧹 Wyczyszczono poprzednie wyniki z tabeli');
          }

          const rois = roisOut();
          if(!rois.length) return notyf.error('Dodaj ROI przed uruchomieniem NCShot');

          const deployment = {
            serialNumber: $('serial-number').value || '',
            locationId: $('location-id').value || '',
            gpsLat: $('gps-lat').value || '',
            gpsLon: $('gps-lon').value || '',
            backendAddr: $('backend-addr').value || '',
            swdallowMasks: $('swdallow-masks').value || '',
            nativeallowMasks: $('nativeallow-masks').value || ''
          };

          if(!deployment.locationId) return notyf.error('Wymagane ID lokalizacji');

          const activeImages = getActiveImages();
          const activeImageData = getActiveImageData();

          if(activeImages.length === 0) {
            return notyf.error('Zaznacz przynajmniej jeden obraz w galerii do przetworzenia');
          }

          console.log('🔧 Debug - NCShot uruchomienie z zarządzaniem pamięcią:');
          console.log('ROI count:', rois.length);
          console.log('Active images count:', activeImages.length);
          console.log('Display scale:', displayScale);
          console.log('Original image:', originalImageWidth, 'x', originalImageHeight);

          // 🔧 ULEPSZONA DIAGNOSTYKA PAMIĘCI z ograniczeniami
          console.log('📊 === DIAGNOSTYKA PAMIĘCI ===');
          let totalSizeKB = 0;
          let activeSizeKB = 0;

          activeImages.forEach((img, i) => {
            const sizeKB = Math.round(img.size / 1024);
            activeSizeKB += sizeKB;
            console.log(`  ${i}: ${img.filename} (ID:${img.id}, size:${sizeKB}KB)`);
          });

          console.log(`📊 ROZMIARY: Aktywne obrazy: ${activeSizeKB}KB`);

          // 🔧 NOWE ZABEZPIECZENIA PAMIĘCIOWE
          const MAX_SAFE_SIZE_KB = 50 * 1024; // 50MB łącznie
          const MAX_SINGLE_IMAGE_KB = 5 * 1024; // 5MB na obraz
          const MAX_IMAGES_COUNT = 15; // Max 15 obrazów na raz

          // Sprawdź łączny rozmiar
          if (activeSizeKB > MAX_SAFE_SIZE_KB) {
            console.warn(`⚠️ OSTRZEŻENIE: Duży łączny rozmiar obrazów (${Math.round(activeSizeKB/1024)}MB)`);
            if (!confirm(`Łączny rozmiar obrazów: ${Math.round(activeSizeKB/1024)}MB przekracza bezpieczny limit ${Math.round(MAX_SAFE_SIZE_KB/1024)}MB. NCShot może mieć problemy z pamięcią. Kontynuować?`)) {
              return;
            }
          }

          // Sprawdź liczbę obrazów
          if (activeImages.length > MAX_IMAGES_COUNT) {
            console.warn(`⚠️ OSTRZEŻENIE: Dużo obrazów (${activeImages.length})`);
            if (!confirm(`Liczba obrazów (${activeImages.length}) przekracza bezpieczny limit (${MAX_IMAGES_COUNT}). Może to powodować problemy z pamięcią. Kontynuować?`)) {
              return;
            }
          }

          // Sprawdź pojedyncze obrazy
          const oversizedImages = activeImages.filter(img => img.size > MAX_SINGLE_IMAGE_KB * 1024);
          if (oversizedImages.length > 0) {
            console.warn(`⚠️ Znaleziono ${oversizedImages.length} oversized obrazów`);
            oversizedImages.forEach(img => {
              console.warn(`  - ${img.filename}: ${Math.round(img.size/1024)}KB`);
            });

            if (!confirm(`Znaleziono ${oversizedImages.length} bardzo dużych obrazów (>5MB). Może to powodować błędy pamięci. Kontynuować?`)) {
              return;
            }
          }

          console.log('🔧 ZARZĄDZANIE PAMIĘCIĄ: Aktywne');
          console.log('🔍 Nazwy plików do przetworzenia:', getCurrentImageFilenames());

          const requestData = {
            package: { rois, deployment },
            image_files: activeImageData
          };

          showResultsPanel();
          updateResultsStats('🚀 Uruchamianie NCShot z zarządzaniem pamięcią...');

          // 🔧 TIMEOUT zwiększony dla dużych obrazów
          const timeoutMs = Math.max(120000, activeImages.length * 10000); // Min 2 min, +10s na obraz
          console.log(`⏱️ Timeout ustawiony na: ${Math.round(timeoutMs/1000)}s`);

          showLoader();
          try{
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

            const res = await fetch('/ncshot/', {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body:JSON.stringify(requestData),
              signal: controller.signal
            });

            clearTimeout(timeoutId);
            const data = await res.json();

            if (!res.ok) {
              console.error('⚠️ Błąd serwera NCShot:', data);

              // 🔧 SPECJALNE KOMUNIKATY DLA BŁĘDÓW PAMIĘCI
              if (res.status === 500 || data.detail?.includes('bad_alloc')) {
                throw new Error('BŁĄD PAMIĘCI: NCShot nie ma wystarczającej pamięci. Spróbuj z mniejszymi obrazami lub mniejszą liczbą na raz.');
              } else if (res.status === 408 || res.status === 504) {
                throw new Error('TIMEOUT: Przetwarzanie trwało zbyt długo. Spróbuj z mniejszą liczbą obrazów.');
              }

              throw new Error(data.detail || 'Nieznany błąd serwera');
            }

            if (data.success && data.results) {
              console.log('🎉 NCShot Professional response otrzymany:', data);
              const stats = displayResultsInBottomPanel(data);
              console.log('📊 Statystyki końcowe:', stats);

              // 🔧 WYMUŚ CZYSZCZENIE PAMIĘCI PRZEGLĄDARKI
              if (window.gc) {
                window.gc(); // Chrome DevTools
              }

              // Pokaż statystyki pamięci jeśli dostępne
              if (performance.memory) {
                console.log('🧠 Pamięć przeglądarki po NCShot:', {
                  used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024) + 'MB',
                  total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024) + 'MB',
                  limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024) + 'MB'
                });
              }

            } else {
              updateResultsStats('⚠️ Błąd przetwarzania wyników');
              notyf.error('Błąd podczas uruchamiania NCShot');
            }

          } catch(e) {
            console.error('⚠️ Błąd w runNcshotProfessional:', e);
            updateResultsStats(`⚠️ Błąd krytyczny: ${e.message}`);

            // 🔧 SPECJALNE KOMUNIKATY DLA RÓŻNYCH TYPÓW BŁĘDÓW
            if (e.name === 'AbortError') {
              notyf.error(`NCShot: Timeout po ${Math.round(timeoutMs/1000)}s. Spróbuj z mniejszą liczbą obrazów.`, {duration: 8000});
            } else if (e.message.includes('BŁĄD PAMIĘCI')) {
              notyf.error(e.message, {duration: 10000});
              // Zasugeruj rozwiązania
              console.log('💡 SUGESTIE ROZWIĄZANIA PROBLEMÓW Z PAMIĘCIĄ:');
              console.log('1. Zmniejsz liczbę obrazów przetwarzanych na raz');
              console.log('2. Użyj mniejszych obrazów (kompresja)');
              console.log('3. Restartuj NCShot service na serwerze');
              console.log('4. Sprawdź dostępną pamięć RAM na serwerze');
            } else if (e.message.includes('TIMEOUT')) {
              notyf.error(e.message, {duration: 8000});
            } else if (e.message.includes('500') || e.message.includes('Internal Server Error')) {
              notyf.error('NCShot: Błąd serwera. Sprawdź logi serwera i spróbuj z mniejszymi obrazami.', {duration: 8000});
            } else {
              notyf.error('NCShot nieudany: ' + e.message, {duration: 6000});
            }
          } finally {
            hideLoader();

            // 🔧 CLEANUP PO ZAKOŃCZENIU
            console.log('🧹 Cleanup po NCShot...');

            // Usuń duże dane z pamięci jeśli możliwe
            requestData.image_files = null;

            // Wymuś garbage collection w przeglądarce
            if (window.gc) {
              window.gc();
            }
          }
      }

      function showResultsPanel() {
        const resultsPanel = $('results-panel');
        resultsPanel.style.display = 'block';
        resultsPanel.classList.remove('collapsed');
        $('results-toggle').textContent = '⬇️ Zwiń';
      }

      function updateResultsStats(message) {
        const statsPanel = $('results-stats-panel');
        statsPanel.textContent = message;
      }

      function displayResultsInBottomPanel(data) {
        console.log('📊 === WYŚWIETLANIE WYNIKÓW W PANELU NA DOLE ===');
        console.log('📊 Otrzymane wyniki:', Object.keys(data.results).filter(k => k !== '_stats'));

        // 🔧 DEBUG MAPOWANIA NAZW
        const currentFilenames = getCurrentImageFilenames();
        console.log('🔍 Aktualne nazwy plików dla mapowania:', currentFilenames);

        const stats = data.results._stats || {};
        const processed = stats.processed || Object.keys(data.results).length - 1;

        const statsPanel = $('results-stats-panel');
        statsPanel.innerHTML = `
          <strong>📊 Statystyki końcowe:</strong>
          Przetworzonych obrazów: <strong>${processed}</strong> |
          Pojazdy: <strong>${stats.total_vehicles || 0}</strong> |
          Tablice: <strong>${stats.total_plates || 0}</strong> |
          Sukces: <strong>${stats.success_rate?.toFixed(1) || 0}%</strong>
        `;

        const tableBody = $('results-table-body');
        tableBody.innerHTML = '';

        let totalPlates = 0;
        let totalImages = 0;
        let imagesWithPlates = 0;
        let platesWithImages = 0;

        for(const [imageKey, result] of Object.entries(data.results)) {
          if(imageKey === '_stats') continue;

          totalImages++;
          console.log(`🖼️ Analizuję wyniki dla ${imageKey}:`, result);

          let hasPlates = false;

          if(result.detailed_plates_with_images && result.detailed_plates_with_images.length > 0) {
            hasPlates = true;
            imagesWithPlates++;

            result.detailed_plates_with_images.forEach((plateData, plateIndex) => {
              if(plateData) {
                totalPlates++;

                if(plateData.has_image && plateData.plate_image) {
                  platesWithImages++;
                }

                const row = createTableRow(imageKey, plateIndex, plateData);
                tableBody.appendChild(row);
              }
            });
          }
          else if(result.parsed_data && result.parsed_data.vehicles) {
            result.parsed_data.vehicles.forEach((vehicle, vehicleIndex) => {
              if(vehicle.plates && vehicle.plates.length > 0) {
                hasPlates = true;
                if (!imagesWithPlates) {
                  imagesWithPlates++;
                }

                vehicle.plates.forEach((plate, plateIndex) => {
                  totalPlates++;
                  const row = createTableRowFromParsedData(imageKey, vehicleIndex, plate, vehicle);
                  tableBody.appendChild(row);
                });
              }
            });
          }

          if (!hasPlates) {
            const row = createNoPlatesRow(imageKey);
            tableBody.appendChild(row);
          }
        }

        const plateImageRatio = totalPlates > 0 ? (platesWithImages / totalPlates * 100).toFixed(1) : 0;

        statsPanel.innerHTML = `
          <strong>📊 Statystyki końcowe:</strong>
          Przetworzonych obrazów: <strong>${totalImages}</strong> |
          Obrazy z tablicami: <strong>${imagesWithPlates}</strong> |
          Rozpoznane tablice: <strong>${totalPlates}</strong> |
          Tablice z obrazami: <strong>${platesWithImages}</strong> (${plateImageRatio}%) |
          Sukces: <strong>${totalImages > 0 ? (imagesWithPlates/totalImages*100).toFixed(1) : 0}%</strong>
        `;

        if(totalPlates > 0) {
          if (platesWithImages === totalPlates) {
            notyf.success(`🚀 NCShot zakończony - rozpoznano ${totalPlates} tablic z obrazami!`);
          } else if (platesWithImages > 0) {
            notyf.success(`🚀 NCShot zakończony - rozpoznano ${totalPlates} tablic (${platesWithImages} z obrazami)!`);
          } else {
            notyf.success(`🚀 NCShot zakończony - rozpoznano ${totalPlates} tablic (bez obrazów miniatur)!`);
          }
        } else {
          notyf.success(`ℹ️ NCShot zakończony - nie wykryto tablic. Sprawdź ROI i jakość obrazów.`);
        }

        return { totalPlates, totalImages, imagesWithPlates, platesWithImages };
      }

      // 🔧 NAPRAWIONA FUNKCJA - uproszczone nazwy plików z debugowaniem
      function createTableRow(imageKey, plateIndex, plateData) {
        const row = document.createElement('tr');

        const confidence = plateData.confidence || plateData.level / 100 || 0;
        let confidenceClass = '';
        if(confidence > 0.7) confidenceClass = 'confidence-excellent';
        else if(confidence > 0.4) confidenceClass = 'confidence-good';
        else confidenceClass = 'confidence-poor';

        row.className = confidenceClass;

        // 🔧 DYNAMICZNE POBIERANIE NAZWY PLIKU z debugowaniem
        const imageIndex = parseInt(imageKey.replace('image_', ''));
        const currentFilenames = getCurrentImageFilenames();
        const filename = currentFilenames[imageIndex] || `Obraz ${imageIndex + 1}`;

        console.log(`🔗 Mapowanie: ${imageKey} (index:${imageIndex}) -> filename: "${filename}"`);
        console.log(`🔗 Dostępne nazwy:`, currentFilenames);

        const cells = [
          filename,  // 🔧 ZAWSZE TYLKO NAZWA PLIKU
          plateIndex + 1,
          plateData.symbol || 'N/A',
          plateData.country || 'N/A',
          plateData.level ? `${plateData.level}%` : 'N/A',
          plateData.type || 'N/A',
          plateData.vehicle_manufacturer || 'N/A',
          plateData.vehicle_model || 'N/A',
          plateData.vehicle_color || 'N/A',
          plateData.mmr_divergence ? plateData.mmr_divergence.toFixed(3) : 'N/A'
        ];

        cells.forEach(cellContent => {
          const cell = document.createElement('td');
          cell.textContent = cellContent;
          cell.title = cellContent;
          row.appendChild(cell);
        });

        const statusCell = document.createElement('td');
        if(plateData.has_image && plateData.plate_image) {
          const thumbImg = document.createElement('img');
          thumbImg.src = plateData.plate_image;
          thumbImg.className = 'plate-thumb';
          thumbImg.title = 'Kliknij aby powiększyć';
          thumbImg.onclick = () => showPlateModal(plateData.plate_image, filename, plateIndex);
          statusCell.appendChild(thumbImg);
        } else {
          statusCell.className = 'plate-status-missing';
          statusCell.textContent = 'Brak obrazu';
          statusCell.title = 'NCShot nie udostępnił obrazu tablicy';
        }
        row.appendChild(statusCell);

        return row;
      }

      function createTableRowFromParsedData(imageKey, vehicleIndex, plate, vehicle) {
        const row = document.createElement('tr');

        const confidence = plate.confidence || 0;
        let confidenceClass = '';
        if(confidence > 0.7) confidenceClass = 'confidence-excellent';
        else if(confidence > 0.4) confidenceClass = 'confidence-good';
        else confidenceClass = 'confidence-poor';

        row.className = confidenceClass;

        // 🔧 DYNAMICZNE POBIERANIE NAZWY PLIKU z debugowaniem
        const imageIndex = parseInt(imageKey.replace('image_', ''));
        const currentFilenames = getCurrentImageFilenames();
        const filename = currentFilenames[imageIndex] || `Obraz ${imageIndex + 1}`;

        console.log(`🔗 Mapowanie (parsed): ${imageKey} (index:${imageIndex}) -> filename: "${filename}"`);

        const cells = [
          filename,  // 🔧 ZAWSZE TYLKO NAZWA PLIKU
          vehicleIndex + 1,
          plate.symbol || 'N/A',
          plate.country || 'N/A',
          plate.level ? `${plate.level}%` : 'N/A',
          plate.type || 'N/A',
          vehicle.vehicle_info?.manufacturer || 'N/A',
          vehicle.vehicle_info?.model || 'N/A',
          vehicle.vehicle_info?.color || 'N/A',
          vehicle.vehicle_info?.mmr_pattern_divergence?.toFixed(3) || 'N/A'
        ];

        cells.forEach(cellContent => {
          const cell = document.createElement('td');
          cell.textContent = cellContent;
          cell.title = cellContent;
          row.appendChild(cell);
        });

        const statusCell = document.createElement('td');
        statusCell.className = 'plate-status-missing';
        statusCell.textContent = 'Fallback - brak obrazu';
        statusCell.title = 'Używa danych fallback bez obrazów tablic';
        row.appendChild(statusCell);

        return row;
      }

      function createNoPlatesRow(imageKey) {
        const row = document.createElement('tr');
        row.className = 'plate-status-error';

        // 🔧 DYNAMICZNE POBIERANIE NAZWY PLIKU z debugowaniem
        const imageIndex = parseInt(imageKey.replace('image_', ''));
        const currentFilenames = getCurrentImageFilenames();
        const filename = currentFilenames[imageIndex] || `Obraz ${imageIndex + 1}`;

        console.log(`🔗 Mapowanie (no plates): ${imageKey} (index:${imageIndex}) -> filename: "${filename}"`);

        const cells = [
          filename,  // 🔧 ZAWSZE TYLKO NAZWA PLIKU
          'Brak',
          'BRAK DETEKCJI',
          'N/A',
          'N/A',
          'N/A',
          'N/A',
          'N/A',
          'N/A',
          'N/A'
        ];

        cells.forEach(cellContent => {
          const cell = document.createElement('td');
          cell.textContent = cellContent;
          cell.className = 'no-plate-info';
          row.appendChild(cell);
        });

        const statusCell = document.createElement('td');
        statusCell.textContent = 'Nie wykryto pojazdów';
        statusCell.title = 'NCShot nie wykrył żadnych pojazdów na obrazie';
        row.appendChild(statusCell);

        return row;
      }

      function showPlateModal(plateImage, filename, plateIndex) {
        try {
          const existingModal = document.querySelector('.plate-modal');
          if (existingModal) {
            document.body.removeChild(existingModal);
          }

          const modal = document.createElement('div');
          modal.className = 'plate-modal';

          const modalContent = document.createElement('div');
          modalContent.className = 'plate-modal-content';

          const title = document.createElement('h3');
          title.textContent = `Tablica ${plateIndex + 1} z pliku ${filename}`;
          title.style.margin = '0 0 15px 0';
          title.style.color = '#333';

          const modalImg = document.createElement('img');
          modalImg.src = plateImage;
          modalImg.alt = 'Tablica rejestracyjna';

          const info = document.createElement('p');
          info.textContent = 'Kliknij w dowolnym miejscu aby zamknąć';
          info.style.cssText = 'margin: 15px 0 0 0; color: #666; font-size: 14px;';

          modalContent.appendChild(title);
          modalContent.appendChild(modalImg);
          modalContent.appendChild(info);
          modal.appendChild(modalContent);

          modal.onclick = () => document.body.removeChild(modal);

          document.body.appendChild(modal);

        } catch (error) {
          console.error('⚠️ Błąd pokazywania modala tablicy:', error);
        }
      }

      async function debugNcshot(){
        console.log('🛠 === DEBUG NCSHOT ===');
        const rois = roisOut();
        const activeImages = getActiveImages();
        console.log('🎯 ROI Data:', rois);
        console.log('🖼️ Active Images:', activeImages.length);

        // 🔧 NOWE: szczegółowe debugowanie stanu galerii
        console.log('📊 === SZCZEGÓŁOWY STAN GALERII ===');
        console.log('Wszystkie obrazy w galerii:', galleryImages.length);
        galleryImages.forEach((img, i) => {
          console.log(`  ${i}: "${img.filename}" (ID:${img.id}, source:${img.source}, active:${img.active}, size:${img.size})`);
        });

        console.log('📊 === AKTYWNE OBRAZY ===');
        activeImages.forEach((img, i) => {
          console.log(`  ${i}: "${img.filename}" (ID:${img.id}, source:${img.source})`);
        });

        console.log('🔍 Current image filenames (aktualnie):', getCurrentImageFilenames());

        console.log('🔍 Gallery state:', galleryImages);
        console.log('🔧 Display scale:', displayScale);
        console.log('🔍 Original image size:', originalImageWidth, 'x', originalImageHeight);
        console.log('🔍 Canvas size:', canvas.width, 'x', canvas.height);
        console.log('🖼️ Current working image:', currentWorkingImage?.filename || 'none');
        console.log('⚖️ Scale calculation check:', {
          'canvas_width / original_width': canvas.width / originalImageWidth,
          'current_displayScale': displayScale,
          'should_be_equal': 'TAK jeśli skalowanie jest prawidłowe'
        });
        console.log('💡 Sprawdź /debug-plates/ endpoint dla szczegółów');

        // Test ROI scaling
        if (rois.length > 0) {
          console.log('🔧 === TEST SKALOWANIA ROI ===');
          rois.forEach((roi, i) => {
            console.log(`ROI ${i+1}:`, {
              id: roi.id,
              'first_point_original': roi.points[0],
              'first_point_should_be_on_canvas': {
                x: roi.points[0]?.x * displayScale,
                y: roi.points[0]?.y * displayScale
              }
            });
          });
        }

        // 🔧 NOWE: debug pending ROIs
        if (pendingRois.length > 0) {
          console.log('🔧 === OCZEKUJĄCE ROI ===');
          console.log('Pending ROIs count:', pendingRois.length);
          console.log('Pending ROIs data:', pendingRois);
        }

        notyf.success('Debug info wyświetlony w konsoli + sprawdź /debug-plates/');
      }

      async function loadXml(ev){
        notyf.error('Import XML ROI dostępny w pełnej wersji');
      }

      // 🔧 NOWE FUNKCJE POMOCNICZE
      function createDefaultRoi() {
        if (!currentWorkingImage) {
          notyf.error('Ustaw obraz roboczy przed tworzeniem ROI');
          return;
        }

        const w = canvas.width;
        const h = canvas.height;
        const roiWidth = w * 0.6;
        const roiHeight = h * 0.4;
        const startX = (w - roiWidth) / 2;
        const startY = (h - roiHeight) / 2;

        const points = [
          {x: startX, y: startY},
          {x: startX + roiWidth, y: startY},
          {x: startX + roiWidth, y: startY + roiHeight},
          {x: startX, y: startY + roiHeight}
        ];

        const color = roiColors[roiCount % roiColors.length];
        roiCount++;

        const poly = new fabric.Polygon(points, {
          fill: color.fill,
          stroke: color.stroke,
          strokeWidth:2,
          selectable:true,
          hasControls:true,
          customData: {
            id:`ROI-${roiCount}`,
            angle:0,
            zoom:0.035,
            reflexOffsetH:0,
            reflexOffsetV:0,
            skewH:0,
            skewV:0
          }
        });

        canvas.add(poly);
        canvas.renderAll();
        notyf.success(`Utworzono domyślne ROI-${roiCount}`);
      }

      function fitRoiToImage() {
        if (!currentWorkingImage) {
          notyf.error('Ustaw obraz roboczy');
          return;
        }

        createDefaultRoi();
      }

      function debugRoi() {
        const rois = roisOut();
        console.log('🔧 === DEBUG ROI V2 ===');
        console.log('ROI count:', rois.length);
        console.log('Display scale:', displayScale);
        console.log('Original image:', originalImageWidth, 'x', originalImageHeight);
        console.log('Canvas size:', canvas.width, 'x', canvas.height);
        console.log('Current working image:', currentWorkingImage?.filename || 'none');
        console.log('Canvas/Original ratio check:', {
          'canvas_width / original_width': canvas.width / originalImageWidth,
          'canvas_height / original_height': canvas.height / originalImageHeight,
          'current_displayScale': displayScale,
          'should_all_be_equal': 'TAK jeśli skalowanie jest prawidłowe'
        });

        rois.forEach((roi, i) => {
          console.log(`ROI ${i+1} (${roi.id}):`);
          console.log('  Exported points (original scale):', roi.points.slice(0,2));

          // Znajdź ROI na canvas
          const canvasRoi = canvas.getObjects().find(obj => obj.customData?.id === roi.id);
          if (canvasRoi) {
            console.log('  Display points (on canvas):', canvasRoi.points.slice(0,2));
            console.log('  Conversion check:', {
              'original_to_display': roi.points.slice(0,2).map(p => ({x: p.x * displayScale, y: p.y * displayScale})),
              'actual_display': canvasRoi.points.slice(0,2),
              'match': 'Powinny być identyczne'
            });
          }
        });

        // 🔧 NOWE: debug pending ROIs
        if (pendingRois.length > 0) {
          console.log('🔧 === OCZEKUJĄCE ROI ===');
          console.log('Pending ROIs count:', pendingRois.length);
          pendingRois.forEach((roi, i) => {
            console.log(`Pending ROI ${i+1} (${roi.id}):`, roi.points?.slice(0,2) || 'brak punktów');
          });
        }

        console.log('🔧 === LOGIKA SKALOWANIA V3 ===');
        console.log('1. ROI zawsze widoczne od razu (jak w starej wersji)');
        console.log('2. Po importie: ROI wyświetlane + zapisane jako pendingRois');
        console.log('3. Po setWorkingImage: pendingRois zastosowane w prawidłowej skali');
        console.log('4. roisOut() konwertuje display → oryginalna skala');
        console.log('5. drawRoisFromOriginalScale() konwertuje oryginalna → display skala');

        notyf.success('Debug ROI v2 wyświetlony w konsoli');
      }

      // 🔧 NOWA FUNKCJA: Monitoring pamięci
      function monitorMemoryUsage() {
        if (!performance.memory) {
          console.log('⚠️ Monitoring pamięci niedostępny w tej przeglądarce');
          return null;
        }

        const memory = performance.memory;
        const memInfo = {
          used: Math.round(memory.usedJSHeapSize / 1024 / 1024),
          total: Math.round(memory.totalJSHeapSize / 1024 / 1024),
          limit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024),
          usage_percent: Math.round((memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100)
        };

        console.log(`🧠 Pamięć: ${memInfo.used}MB / ${memInfo.limit}MB (${memInfo.usage_percent}%)`);

        // Ostrzeżenie przy wysokim użyciu pamięci
        if (memInfo.usage_percent > 80) {
          console.warn(`⚠️ WYSOKIE UŻYCIE PAMIĘCI: ${memInfo.usage_percent}%`);
          notyf.warning(`Wysokie użycie pamięci: ${memInfo.usage_percent}%. Rozważ restart przeglądarki.`);
        }

        return memInfo;
      }

      // 🔧 ULEPSZONA FUNKCJA: Optymalizacja galerii obrazów
      function optimizeGalleryMemory() {
        console.log('🔧 Optymalizacja pamięci galerii...');

        // Usuń nieaktywne obrazy z pamięci (zachowaj tylko metadane)
        let savedMemory = 0;
        galleryImages.forEach(img => {
          if (!img.active && img.data) {
            savedMemory += img.size || 0;
            img.data = null; // Usuń dane obrazu, zachowaj metadane
            img.compressed = true;
          }
        });

        if (savedMemory > 0) {
          console.log(`💾 Zwolniono ${Math.round(savedMemory/1024)}KB pamięci`);
          notyf.success(`Zoptymalizowano pamięć: +${Math.round(savedMemory/1024)}KB`);
        }

        updateGalleryDisplay();
      }

      console.log('✅ Wszystkie funkcje załadowane!');
    </script>
    </body>
    </html>
